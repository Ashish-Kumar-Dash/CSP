<!DOCTYPE html>
<html lang="en">

<head>
    <title>HERMEZ GARAGE</title>
    <link rel="stylesheet" href="index.css">
</head>

<body>
    <canvas id="backgroundCanvas"></canvas>
    <canvas id="starsCanvas"></canvas>
    <canvas id="milkyWayCanvas"></canvas>

    <header class="hermez-header" id="heroHeader">
        <div class="hermez-logo-container">
            <img src="./images/logo.png" alt="Hermez Logo" />
            <div>
                <div class="hermez-title">HERMEZ</div>
                <div class="hermez-domain">.COM</div>
            </div>
        </div>
        <div class="hermez-tagline"> WE WILL HELP YOU FIND THE PRIDE FOR YOUR GARAGE !!</div>
    </header>

    <main>
        <div class="intro">
            <h3>Why buy your car from Hermez?</h3>
            <p>Skip dealership hassles and buy your next car easily from home with Hermez. Whether upgrading,
                relocating, or looking for a reliable ride, Hermez offers a fast, safe, and fully digital car buying
                experience.</p>
            <p>Instant search, transparent pricing, and doorstep inspection make buying your car simple and
                hassle-free. Hermez handles all paperwork, including registration and documentation, so you can focus on
                enjoying your new car.</p>

            <h4>Why choose Hermez for buying cars online?</h4>
            <ul>
                <li>Buy from anywhere with easy online browsing and scheduling</li>
                <li>Get fair and competitive prices powered by AI-driven market data</li>
                <li>Convenient doorstep inspection and delivery</li>
                <li>Secure, quick payment options</li>
                <li>Complete ownership transfer with hassle-free document management</li>
            </ul>

            <h4>How it works:</h4>
            <ol>
                <li>Search cars and get instant market-based price estimates</li>
                <li>Schedule a free doorstep inspection by Hermez experts</li>
                <li>Confirm your purchase and pay securely online</li>
                <li>Let Hermez handle paperwork and vehicle registration for you</li>
            </ol>

            <h4>Why Hermez offers the best value</h4>
            <p>Hermez leverages technology and a wide dealer network to provide competitive prices and a broad
                selection. Its transparent auction-style pricing ensures you get great deals securely and conveniently.
            </p>

            <h4>Benefits of buying from Hermez</h4>
            <ul>
                <li>Convenient digital experience from search to delivery</li>
                <li>Transparent pricing backed by real market data</li>
                <li>Trusted doorstep inspection and delivery service</li>
                <li>Quick, secure payments</li>
                <li>Full support with documentation and registration</li>
            </ul>

            <p><strong>Hermez is your smarter, simpler way to buy quality cars online.</strong></p>
        </div>

        <section class="car-grid">
            <div class="car"><img src="./images/suv.png" width="150">
                <h2>SUV</h2>
            </div>
            <div class="car"><img src="./images/sedan.png" width="150">
                <h2>Sedan</h2>
            </div>
            <div class="car"><img src="./images/hatchback.png" width="150">
                <h2>Hatchback</h2>
            </div>
            <div class="car"><img src="./images/station-wagon.png" width="150">
                <h2>Wagon</h2>
            </div>
            <div class="car"><img src="./images/minivan.png" width="150">
                <h2>Van</h2>
            </div>
            <div class="car"><img src="./images/crossover.png" width="150">
                <h2>Crossover</h2>
            </div>
            <div class="car"><img src="./images/coupe.png" width="150">
                <h2>Coupe</h2>
            </div>
            <div class="car"><img src="./images/convertible.png" width="150">
                <h2>Convertible</h2>
            </div>
            <div class="car"><img src="./images/pickup-truck.png" width="150">
                <h2>Pick-up</h2>
            </div>
        </section>
    </main>

    <script>
        // To ensure we use native resolution of screen
        var dpr = window.devicePixelRatio || 1;

        // getting canvases with native resolution
        const canvas = document.getElementById("starsCanvas");
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr); // to scale every drawing operations
        const canvasMw = document.getElementById("milkyWayCanvas");
        canvasMw.width = window.innerWidth * dpr;
        canvasMw.height = window.innerHeight * dpr;
        const ctxMw = canvasMw.getContext('2d');
        ctxMw.scale(dpr, dpr); // to scale every drawing operations

        // constants for the behavior of the model
        const sNumber = 600;              // number of Stars
        const sSize = .3;                 // minimum size of Star
        const sSizeR = .6;                // randomness of the size of Stars
        const sAlphaR = .5;               // randomness of alpha for stars
        const sMaxHueProportion = .6;     // max proportion of displayed base hue
        // Shooting stars parameters
        const shootingStarDensity = 0.01;
        const shootingStarBaseXspeed = 30;
        const shootingStarBaseYspeed = 15;
        const shootingStarBaseLength = 8;
        const shootingStarBaseLifespan = 60;
        // Shooting star colors
        const shootingStarsColors = [
            "#a1ffba", // greenish
            "#a1d2ff", // blueish
            "#fffaa1", // yellowish
            "#ffa1a1"  // redish
        ];
        // milky way constants
        const mwStarCount = 100000;     // amount of static stars not clustered in the milky way
        const mwRandomStarProp = .2;    // proportion of stars completely random in the milky way
        const mwClusterCount = 300;     // amount of clusters in the milky way
        const mwClusterStarCount = 1500;// amount of stars per cluster
        const mwClusterSize = 120;      // minimum size of a cluster
        const mwClusterSizeR = 80;      // randomness of the size of a cluster
        const mwClusterLayers = 10;     // amount of layers per cluster to draw
        const mwAngle = 0.6;            // to incline the milky way (0 is horizontal, tend to infinite to get vertical)
        const mwHueMin = 150;           // min hue for a cluster (150 is green)
        const mwHueMax = 300;           // max hue for a cluster (300 is pink)
        const mwWhiteProportionMin = 50;// minimum base percentage of white in cluster hue
        const mwWhiteProportionMax = 65;// maximum base percentage of white in cluster hue

        // array containing random numbers
        let randomArray;
        const randomArrayLength = 1000;
        let randomArrayIterator = 0;
        // array containing random hues
        let hueArray;
        const hueArrayLength = 1000;
        // arrays containing all Stars
        let StarsArray;
        let ShootingStarsArray;



        // Star creation
        class Star {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.alpha = size / (sSize + sSizeR);
                this.baseHue = hueArray[Math.floor(Math.random() * hueArrayLength)];
                this.baseHueProportion = Math.random();
                this.randomIndexa = Math.floor(Math.random() * randomArrayLength);
                this.randomIndexh = this.randomIndexa;
                this.randomValue = randomArray[this.randomIndexa];
            }
            // method to draw each Star
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                let rAlpha = this.alpha + Math.min((this.randomValue - 0.5) * sAlphaR, 1);    // random alpha for the shimmering
                let rHue = randomArray[this.randomIndexh] > this.baseHueProportion ? hueArray[this.randomIndexa] : this.baseHue; // random hue or base hue
                this.color = "hsla(" + rHue + ",100%,85%," + rAlpha + ")";
                ctx.fillStyle = this.color;
                ctx.fill();
            }
            // method to check position of Star
            update() {
                this.randomIndexh = this.randomIndexa;
                this.randomIndexa = (this.randomIndexa >= 999) ? 0 : this.randomIndexa + 1;
                this.randomValue = randomArray[this.randomIndexa];
                // draw Star
                this.draw();
            }
        }

        // Shooting Star creation
        class ShootingStar {
            constructor(x, y, speedX, speedY, color) {
                this.x = x;
                this.y = y;
                this.speedX = speedX;
                this.speedY = speedY;
                this.framesLeft = shootingStarBaseLifespan;
                this.color = color;
            }

            // method to know if the star will be dead on next draw
            goingOut() {
                return this.framesLeft <= 0;
            }
            // method to get the modifier based on the age of the shooting star
            // when freshly born or close to die the length and brightness are reduced
            ageModifier() {
                let halfLife = shootingStarBaseLifespan / 2.0;
                return Math.pow(1.0 - Math.abs(this.framesLeft - halfLife) / halfLife, 2);
            }

            // method to draw each Star
            draw() {
                let am = this.ageModifier();
                let endX = this.x - this.speedX * shootingStarBaseLength * am;
                let endY = this.y - this.speedY * shootingStarBaseLength * am;
                // linear gradient for the color of the shooting star
                let gradient = ctx.createLinearGradient(this.x, this.y, endX, endY);
                gradient.addColorStop(0, "#fff");         // brigth a the start
                gradient.addColorStop(Math.min(am, .7), this.color);     // colored in the middle
                gradient.addColorStop(1, "rgba(0,0,0,0)");// dim a the end

                // drawing
                ctx.strokeStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
            // method to check position of Star
            update() {
                this.framesLeft--;
                this.x += this.speedX;
                this.y += this.speedY;
                // draw Star
                this.draw();
            }
        }

        // star cluster in the milky way
        class MwStarCluster {
            constructor(x, y, size, hue, baseWhiteProportion, brigthnessModifier) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.hue = hue;
                this.baseWhiteProportion = baseWhiteProportion;
                this.brigthnessModifier = brigthnessModifier;
            }

            draw() {
                let starsPerLayer = Math.floor(mwClusterStarCount / mwClusterLayers);
                for (let layer = 1; layer < mwClusterLayers; layer++) {
                    let layerRadius = this.size * layer / mwClusterLayers;
                    for (let i = 1; i < starsPerLayer; i++) {
                        let posX = this.x + 2 * layerRadius * (Math.random() - .5);
                        let posY = this.y + 2 * Math.sqrt(Math.pow(layerRadius, 2) - Math.pow(this.x - posX, 2)) * (Math.random() - .5);
                        let size = .05 + Math.random() * .15;
                        let alpha = .3 + Math.random() * .4;
                        let whitePercentage = this.baseWhiteProportion + 15 + 15 * this.brigthnessModifier + Math.floor(Math.random() * 10);
                        ctxMw.beginPath();
                        ctxMw.arc(posX, posY, size, 0, Math.PI * 2, false);
                        ctxMw.fillStyle = "hsla(" + this.hue + ",100%," + whitePercentage + "%," + alpha + ")";  // 290 deg is pinkish color
                        ctxMw.fill();
                    }
                }
                // adding an extra gradient
                let gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, "hsla(" + this.hue + ",100%," + this.baseWhiteProportion + "%,0.002)");         // dim center
                gradient.addColorStop(0.25, "hsla(" + this.hue + ",100%," + (this.baseWhiteProportion + 30) + "%," + (0.01 + 0.01 * this.brigthnessModifier) + ")");         // brigth around center
                gradient.addColorStop(0.4, "hsla(" + this.hue + ",100%," + (this.baseWhiteProportion + 15) + "%,0.005)");     // colored in the middle
                gradient.addColorStop(1, "rgba(0,0,0,0)");// dim a the end
                ctxMw.beginPath();
                ctxMw.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                ctxMw.fillStyle = gradient;
                ctxMw.fill();
            }

        }

        // create Star array, positions are randomized
        function init() {
            // init random array
            randomArray = [];
            for (let i = 0; i < randomArrayLength; i++) {
                randomArray[i] = Math.random();
            }
            // init hueArray
            hueArray = [];
            for (let i = 0; i < hueArrayLength; i++) {
                // Determining a star hue, ranges from 0 to 60 then 170 to 270 (basically all but green and pink)
                let rHue = Math.floor(Math.random() * 160); // usually hue ranges from 0 to 360 but using only 0 to 160 because of next line
                if (rHue > 60) rHue += 110; // to avoid greenish looking stars (hue from 60 to 170), feels unnatural
                hueArray[i] = rHue;
            }

            StarsArray = [];
            for (let i = 0; i < sNumber; i++) {
                let size = (Math.random() * sSizeR) + sSize;
                let x = Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2;
                let y = Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2;

                StarsArray.push(new Star(x, y, size));
            }

            ShootingStarsArray = [];

            DrawMilkyWayCanvas();
        }

        function animate() {
            requestAnimationFrame(animate);

            ctx.clearRect(0, 0, innerWidth, innerHeight);

            for (let i = 0; i < StarsArray.length; i++) {
                StarsArray[i].update();
            }

            if (randomArray[randomArrayIterator] < shootingStarDensity) {
                let posX = Math.floor(Math.random() * canvas.width);
                let posY = Math.floor(Math.random() * 150);
                let speedX = Math.floor((Math.random() - .5) * shootingStarBaseXspeed);
                let speedY = Math.floor(Math.random() * shootingStarBaseYspeed);
                let color = shootingStarsColors[Math.floor(Math.random() * shootingStarsColors.length)];
                ShootingStarsArray.push(new ShootingStar(posX, posY, speedX, speedY, color));
            }

            let arrayIterator = ShootingStarsArray.length - 1;
            while (arrayIterator >= 0) {
                if (ShootingStarsArray[arrayIterator].goingOut() == true) {
                    ShootingStarsArray.splice(arrayIterator, 1);
                }
                else {
                    ShootingStarsArray[arrayIterator].update();
                }
                arrayIterator--;
            }

            if (randomArrayIterator + 1 >= randomArrayLength) {
                randomArrayIterator = 0;
            }
            else {
                randomArrayIterator++;
            }
        }

        function MilkyWayX() {
            return Math.floor(Math.random() * innerWidth);
        }

        function MilkyWayYFromX(xPos, mode) {
            let offset = ((innerWidth / 2) - xPos) * mwAngle;
            if (mode == "star") {
                return Math.floor(Math.pow(Math.random(), 1.2) * innerHeight * (Math.random() - .5) + innerHeight / 2 + (Math.random() - .5) * 100) + offset;
            }
            else {
                return Math.floor(Math.pow(Math.random(), 1.5) * innerHeight * .6 * (Math.random() - .5) + innerHeight / 2 + (Math.random() - .5) * 100) + offset;
            }
        }

        function DrawMilkyWayCanvas() {
            for (let i = 0; i < mwStarCount; i++) {
                ctxMw.beginPath();
                let xPos = MilkyWayX();
                let yPos = Math.random() < mwRandomStarProp ? Math.floor(Math.random() * innerHeight) : MilkyWayYFromX(xPos, "star");
                let size = Math.random() * .27;
                ctxMw.arc(xPos, yPos, size, 0, Math.PI * 2, false);
                let alpha = .4 + Math.random() * .6;
                ctxMw.fillStyle = "hsla(0,100%,100%," + alpha + ")";
                ctxMw.fill();
            }
            for (let i = 0; i < mwClusterCount; i++) {
                let xPos = MilkyWayX();
                let yPos = MilkyWayYFromX(xPos, "cluster");
                let distToCenter = (1 - (Math.abs(xPos - innerWidth / 2) / (innerWidth / 2))) * (1 - (Math.abs(yPos - innerHeight / 2) / (innerHeight / 2)));
                let size = mwClusterSize + Math.random() * mwClusterSizeR;
                let hue = mwHueMin + Math.floor((Math.random() * .5 + distToCenter * .5) * (mwHueMax - mwHueMin));
                let baseWhiteProportion = mwWhiteProportionMin + Math.random() * (mwWhiteProportionMax - mwWhiteProportionMin);
                new MwStarCluster(xPos, yPos, size, hue, baseWhiteProportion, distToCenter).draw();
            }
        }

        init();
        animate();
        const header = document.getElementById('heroHeader');
        window.addEventListener('scroll', () => {
            if (window.scrollY > 90) {
                header.classList.add('scrolled');
            } else {
                header.classList.remove('scrolled');
            }
        });
        function colourChecker(r, g, b) {
            if (r * 0.299 + g * 0.587 + b * 0.114 < 127) {
                return false;
            } else {
                return true;
            }
        }
        function randomColor() {
            var r = Math.floor(Math.random() * 255);
            var g = Math.floor(Math.random() * 255);
            var b = Math.floor(Math.random() * 255);
            return colourChecker(r, g, b) ? 'rgb(' + r + ',' + g + ',' + b + ')' : randomColor();
        }
        document.addEventListener('DOMContentLoaded', function () {
            document.querySelectorAll('.car').forEach(function (el) {
                el.style.backgroundColor = randomColor();
            });
        });
        document.querySelectorAll('.car').forEach(function (card) {
            card.addEventListener('click', function () {
                var type = card.querySelector('h2').innerText.trim();
                window.location.href = 'main.html?type=' + encodeURIComponent(type);
            });
        });
    </script>
</body>

</html>